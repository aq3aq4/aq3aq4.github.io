---
title: "ProtoBuf에 대한 정리 와 예제를 통한 사용 방법 확인"
ategories: 
    - Back-End
    - ProtoBuf
tags: 
    - Back-End
    - ProtoBuf
---

## Protocol Buffer를 왜 쓰는가?
우선 Protocol Buffer가 무엇인지 알기 위해서는 Protocol Buffer를 사용하지 않았을 경우 어떻게 다른 서비스 간 데이터 교환을 하는지에 대해서 생각해보자.    
여러 가지가 있을 수 있지만, 첫번째로는 Rest API 방식으로 다른 서비스의 메소드를 호출 해 응답값을 가져 갈 수 있고, 이 과정에서 JSON 혹은 XML 등의 포맷을 사용하게 된다. 두번째는 Socket 방식을 사용 해 특정 언어에서 제공하는 직렬화를 사용해서 데이터를 교환할 수 있다.    
위 2가지는 각각의 약점을 가지고 있는데 첫번째로 설명한 Rest API의 JSON 혹은 XML 포맷 교환 방식은 Spring 또는 다른 웹 프레임워크를 사용하게 되면 간단하게 사용할 수 있지만 사실 내부적으로 보게 되면 응답할 결과 객체를 JSON으로 파싱하거나 전달 받은 JSON을 객체로 파싱하는 등의 작업을 거치면서 성능 저하를 발생 시킨다.      
두번째의 방식은 언어 혹은 플랫폼에 종속되는 문제를 가진다. 예를 들어 JAVA로 구성 된 A 서비스의 주문조회 서비스에서 결과 값을 직렬화 해서 전달하면 A의 주문조회 서비스를 호출하는 B 서비스는 JAVA로 구성되지 않으면 전달 받은 직렬화된 내용을 역직렬화 할 수 없다.      
즉, 전체적인 시스템을 구성하는 프로젝트들의 개발 언어가 특정언어로 종속되어 버리는 문제가 발생된다.     
이러한 문제를 해결 하기 위해 사용하는 것이 Protocol Buffer 이다. 

## Protocol Buffer란?
Protocol Buffer는 데이터를 파일 또는 네트워크로 전송 될 수 있도록 직렬화 하는 방법 중 하나이며, JSON, XML과 마찬가지로 언어 및 플랫폼 중립적이고, JSON과 XML보다 훨씬 빠르게 처리가 가능하다. 

## Protocol Buffer 동작 방식
```text
{
    "userName": "Martin",
    "favouriteNumber": 1337,
    "interests": ["daydreaming", "hacking"]
}
```
위와 같은 JSON 결과 값이 있고, 이 결과 값을 응답결과로 전송하게 되면 82바이트가 사용된다.    
```proto
message Person {
    required string user_name        = 1;
    optional int64  favourite_number = 2;
    repeated string interests        = 3;
}
```
위와 같은 Person이라는 Proto 정의가 있을 때 ProtoCol Buffer는 아래 그림 처럼 동작하게 된다. 
![protoImg1](/assets/images/backend/protobuf/protobuf_small.png)    
우선 JSON은 데이터 값을 제외하고도 userName, favouriteNumber와 같은 필드 값도 포함을 하지만 Protocol Buffer의 경우 해당 필드 명을 Person 메시지의 변수에 정의한 숫자 1,2,3를 사용해 필드명을 대체 한다. 이런 식으로 줄일 수 있는 부분들은 최대한 줄여서 데이터의 용량을 줄이는 것이다.

## Protocol Buffer 특징
1. 바이너리 전송   
Protocol Buffer는 데이터가 바이너리 형식으로 전송되어 적은 공간과 대역폭을 차지하기 때문에 JSON 혹은 XML으로 파싱된 문자열보다 전송 속도를 향상 시킨다.
대신 바이너리로 전송되기 때문에 사람이 읽을 수 없는 단점이 존재하지만, 성능을 고려해 볼 때 충분히 감안할 수 있는 단점이라고 생각이 든다. 
2. 필드와 값의 분리
동작 방식에서 보았듯이 JSON의 경우 필드값과 데이터 값을 가지지만, Protocol Buffer의 경우 정의된 플래그 값으로 대체 시켜 버린다.  
3. 언어 및 플랫폼 선택에 자유롭다. 
언어 및 플랫폼에 종속된 직렬화 방식이 아니라, Protocol Buffer의 고유 직렬화 방식이므로 언어 및 플롯폼과 관련이 없다. 


## Protocol Buffer의 .proto 분석하기
아래는 Protocol Buffer를 사용하기 위해 메시지를 정의한 .proto 파일의 내용이다.     
주석을 이용해서 각 선언이 무슨 의미를 가지는지 설명한다.     
```java
// 사용할 proto 버전에 따른 syntax 정의, proto2 와 proto3이 있다. 
syntax = "proto2";

//다른 프로젝트간 이름 충돌방지를 위한 선언
package tutorial;


option java_package = "com.example.tutorial";
option java_outer_classname = "AddressBookProtos";

message Person {
  required string name = 1;
  required int32 id = 2;
  optional string email = 3;

  enum PhoneType {
    MOBILE = 0;
    HOME = 1;
    WORK = 2;
  }

  message PhoneNumber {
    required string number = 1;
    optional PhoneType type = 2 [default = HOME];
  }

  repeated PhoneNumber phones = 4;
}

message AddressBook {
  repeated Person people = 1;
}
```



## 참고 자료
[https://codeclimate.com/blog/choose-protocol-buffers/](https://codeclimate.com/blog/choose-protocol-buffers/)   
[벤치마크 관련](https://blog.usejournal.com/what-the-hell-is-protobuf-4aff084c5db4)     
[https://developers.google.com/protocol-buffers/docs/javatutorial] https://developers.google.com/protocol-buffers/docs/javatutorial